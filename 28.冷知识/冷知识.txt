1.利用a标签自动解析URL
myURL.file;     // = 'index.html'
myURL.hash;     // = 'top'
myURL.host;     // = 'abc.com'
myURL.query;    // = '?id=255&m=hello'
myURL.params;   // = Object = { id: 255, m: hello }
myURL.path;     // = '/dir/index.html'
myURL.segments; // = Array = ['dir', 'index.html']
myURL.port;     // = '8080'
myURL.protocol; // = 'http'
myURL.source;   // = 'http://abc.com:8080/dir/index.html?id=255&m=hello#top'

2.页面拥有ID的元素会创建自动全局变量
<div id="sample"></div>
<script type="text/javascript">
        console.log(sample);
</script>

3.加载CDN文件时，可以省掉HTTP标识
<script src="//libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>

4.利用script标签保存任意信息
<script type="text" id="template">
    <h1>This won't display</h1>
</script>

var text = document.getElementById('template').innerHTML

5.把浏览器当编辑器 data:text/html,<html contenteditable>

6.将以下代码放到console执行后，整个页面将变得可编辑！document.body.contentEditable='true';

7.contentEditable可以让标签进入可编辑状态

8.调试样式的时候可以实时的：
<body>
<div id="app">
    // 在body中添加这个:
    <style style="display:block" contentEditable>
        h1 { color: blue }
    </style>
    <h1>{{ msg }}</h1>
</div>
</body>

9.pageX是点击处移动端的相对整个视图X值，e = event || window.event; e.orginalEvent.touches[0].pageX;
screenX是点击处网页端相对于整个视图的X值，offsetLeft相对于父视图的X值只读的，jquery对象本身就是一个伪数组，第0个元素是这个标签本身；

10.兼容性问题
A.li标签下不要嵌套多个div，最合理的结构是ul li a span，可能会造成IE低版本浏览器兼容问题；

11.浮点数快速取整: (12.4 / 4.13) | 0 或 ～～(12.3)

12.快速转化为bool值 ~~a

13.字面量对象的某个属性是箭头函数时，函数里面的this就是window；

14.new Number（）虽然是number类型，数字，但不是真正的数字还有对象的额外功能；在堆区

15.string number bool Object function undefine （null），函数广义上属于一种对象

16.事件传播先捕获到根节点，再传递到目标节点，再冒泡到根节点

17.基础对象指原型链终点的对象。基础对象的原型是null就是没有原型；

18.所有对象键都会被存储为字符串,当对象转字符串时会变成"[Object object]",所以不管时什么对象，转成的字符串都是一样的

19.const arr = [1,2,3];数组是常量了，可以在里面扩充数据numbers[10] = 11;，只是arr不能再指向其他对象，没有填充的部分就是empty;

20.css的加载不会阻塞DOM树的解析，但是会阻塞DOM树的渲染显示，也会阻塞后面的js的运行；解决办法，1.使用CDN，css压缩，缓存，减少http请求数

21.js的加载阻塞DOM树的形成显示，所以加载比较大的js文件时会是白板；因为加载的js中可能会创建，删除节点等，这些操作会对dom树产生影响，如果不阻塞，等浏览器解析完标签生成dom树后，js修改了某些节点，那么浏览器又得重新解析，然后生成dom树，性能比较差

22.css,js下载失败后，依然会进行DOM树的渲染显示；

23.//判断系统
            let u = navigator.userAgent;
            let isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1; //g
            let isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
            if (isAndroid) {
                this.system = 'Android';
            } else if (isIOS) {
                this.system = 'IOS';
            } else {
                this.system = 'pc';
            }

24. <script>
        window.onload = function(){
            getRem(720,100)
        };
        window.onresize = function(){
            getRem(720,100)
        };
	window.onorientationchange = function() {
	    getRem(720,100)
	}
        function getRem(pwidth,prem){
            var html = document.getElementsByTagName("html")[0];
            var oWidth = document.body.clientWidth || document.documentElement.clientWidth;
            html.style.fontSize = oWidth/pwidth*prem + "px";
        }
        /*
        //小米官网的写法
        !function(n){
            var  e=n.document,
                 t=e.documentElement,
                 i=720,
                 d=i/100,
                 o="orientationchange"in n?"orientationchange":"resize",
                 a=function(){
                     var n=t.clientWidth||320;n>720&&(n=720);
                     t.style.fontSize=n/d+"px"
                 };
                 e.addEventListener&&(n.addEventListener(o,a,!1),e.addEventListener("DOMContentLoaded",a,!1))
        }(window);*/
    </script>

25.Vue中的指令一般用于初始化标签的时候定义标签的状态或者抽出来动态改变标签的状态，分为全局指令Vue.directive('demo',{bind(){},}),局部指令directives:{demo:{bind(el,binding){}}},抽出来通过mixins:[direcs],export const direcs = {directives: {demo: {bind(el){}}}}


