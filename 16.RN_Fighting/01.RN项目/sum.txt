第一节课
1.安装命令加上—save是为了把第三方组件添加到package.json里面
2.图片放在webstorm工程，通过require加载时选择正常图片，但也要把@2x，@3x图加进来便于不同机型加载
3.可以在static propTypes={}中设置组件的类型检查：PropTypes.string PropTypes.element,PropType.bool,同时可以通过，设置默认属性：static defaultProps={}

第二节课
1.由于电脑系统的原因，暂时使用react-navigation@1.4.0,整体用法和最新版本差不多
2.页面的导航跳转必须在导航页面进行配置，在StackNavigator里面的第二个参数中navigationOptions可以全局设置导航样式{header: null},优先级最低,也可以在具体页面下单独设置导航样式和是否这个页面显示导航，优先级第二，也可以在具体页面的js文件里面设置:static navigationOptions = {()=>{}},优先级最高，且导航的样式如果要写成全局，最好就在导航的js文件里面设置
3.全局的navigationOptions会在页面加载完成后就调用，具体的某个页面的导航是在页面出现时调用，所有具体某个页面的导航的处理可以在两个地方，一个是配置导航的js中，优先级第二，另一个是具体页面中，优先级第一
4.可以先在navigationOptions里面设置导航title从navigatin.params.title里面拿，然后在navigation.setParams({title: ‘参数’})设置就会动态设置title了
5.可以直接将AppTabNavgator导出到根结点，这样就显示了tabbar但没有导航,为了有导航，可以将AppTabNavigator最为AppNavigator的一个screen，跳转进去即可
6.由于iOS和安卓使用的TabBar不一致，这个时候就需要用tabBarComponent属性自定义tabBar，tabbar之间的切换依然是this.props.navigation.navigate(‘Page2’)
7.自定义的tabBarComponent从this.props.navigationState里面拿到{routes,index},然后通过routes[index].params拿到参数，在这个页面js中通过设置setParams({theme: {}})来动态全局改变主题色

第三节课
1.ListView没有复用机制，所有item的渲染是全量的
2.VirturlizedList是flatList和SectionList的底层，在窗口之外的元素将会从组件结构上卸载达到回收内存的目的
3.RN中的Fetch是全局的，不需要导入
4.App启动(加载RN引擎)->index.js(js部分入口)->setup.js(组件和服务初始化)->首页
5.module.exports导入是同步的，导出本地文件，可以用于导出一个对象或者json数据或者一个class，或者是一个方法，当是一个方法的时候，外面在require或者import的时候，拿到的是这个function里面return的内容，使用export default也是一样拿到的是function中return的内容
6.从某个页面跳转到Tabbar里面，这里需要重置路由this.props.navigator.resetTo()，让页面不再回来到这个页面了
7.如果有计时器，可以在页面即将卸载的时候销毁计时器，componentWillUnmount(){}
8.StackNavigator外面还可以包装一层SwitchNavigator，用于重置导航，比如欢迎页跳转到框架页

第四节课
1.ios设备上阴影用shadowColor，shadowOffset等等，安卓上用elevation: 2来设置
2.AsyncStorage,简单的，异步的，持久化key-value存储系统，官方推荐，代替LocalStorage，iOS上，较少的数据会放在序列化字典中，大会在单独的文件中，Andriod会在：localDB／sqlite
3.导航条返回按钮，就单独在每个页面设置自己的，先用ViewUtil封装一个class中有方法返回一个带回调的返回按钮，然后在需要的页面导航配置上写： {
                headerLeft:ViewUtil.getLeftButton(()=>{
                    navigation.goBack()
                })
            }
4.export default class Text { static fetch() {}} 中用static定义的方法属于类方法，在外面必须要用这个类使用，不加static是对象方法，要new一下了再使用
5.react-native-check-box安装使用
6.export defualt class LanguageDao {constructor(flag) {this.flag = flag}} 在外面用对象方法时，要new一下时构造函数要传入flag，可以将flag的不同值作为一个对象export const FLAG = {flag1,flag2...}等导出，
7.监听整个界面各个组件有没有状态变化，可以定义一个空数组，再遍历这个数组，存在item就删除，不存在就加进去，最后看数组长度是不是为0来判断这个界面有没有变化
8.RN中的通知分iOS和安卓，通过Platform来区分，NativeAppEventEmitter.addListener("noticeName",(param)=>{})是iOS的，DeviceEventEmitter是安卓的，通过DeviceEventEmitter.emit('noticeName',param)来派发事件


第五节课
1.js中的对象比如数组和object，只要其地址是一样的，对象里面的元素改变了这个对象依然是这个对象，比如 tm = [];p = tm, p[0] = 1,那么 tm === p依然成立
2.子组件通过props接受父组件传递的数据显示UI，当父组件传递的数据有变化时，子组件是无法驱动响应改变UI的，这个时候分情况处理，当父组件有多个这样的子组件时，改变UI的事情就交给子组件自己处理（将数据通过状态机持有,然后将修改的源数据丢出去，或者在父组件里面自己处理源数据），当只有一个子组件时，可以获取子组件调用子组件的方法来处理
3.定义一个组件，让组件拥有系统的style={{}}，分三步走:
  A ViewPropTypes as RNViewPropTypes 在react-native里面
  B const ViewPropTypes = RNViewPropTypes || View.propTypes;
  C ...ViewPropTypes 写在属性里面 static propsType = {...ViewPropTypes}
4.react-native-scrollable-tab-view渲染出来的时候，如果里面的tabLabel对应的界面数量很多且还不确定时就会一直闪烁，解决办法是先判断里面的界面数量计算出来没this.state.dataArray>0?<ScrollableTabView/>:null
5.Alert组件是两个平台都可以使用的
6.页面参数的传递通过导航也可以拿到的，
7.js的继承优化方案: 1.原型 = new Func(）性能和效率不行，2.将通用的属性和方法抽离到原型上，原型 = Base.proptype,一个改多个改了， 3.中间函数: temp = function() {} temp.proptype = Base.proptype, Child.proptype = new temp(),然后将原型的构造函数设为Child自己即可，这个方法和Child.protype = Object.create(new temp())异曲同工之效
8. &&是遇到为false就停止并返回此项的值，如果没有就执行完毕并返回最后项的值
9. ||是遇到为true就停止并返回此项的值，如果都是true就执行到最后并返回最后项的值








