S第一节课
1.模块化，解决命名冲突和文件依赖和无法私有性，如日志模块,最早常采用命名空间法来做的，var caculator = {}, caculator.add=function() {}
2.驼峰命名法+匈牙利命名法(加上了类型)如numA，fnCaculator=function(){}
3.还可以使用(function(){})()来定义模块
4. Sea.js是CMD的规范，阿里巴巴的玉伯开发的
5.开发环境用原版的jquery.js的话，生产环境要用jquery.min.js文件，请求的文件更小
6.Sea.js开始解决了依靠html来加载各个js文件了，JS中可以加载其他的JS了

第二节课
1.nodejs中每个文件都是一个模块，通过module.exports输入，通过require打破封装性进行引入；
2.require的原理，通过module.exports输入后，require本身是一个函数，引入路径参数后，读取js模块文件内容进行拼接字符串，然后eval执行获取函数，执行和这个函数的到js模块里面exports或者module.exports输入的函数或数据；
3.module就是一个全局属性，通过require后，第一次会执行js里面所有的代码，然后将module对象缓存起来，下次require直接从缓存中module对象中取，js模块中无关代码不会再执行；
4.module对象包含id(最外层的是.)，export对象 parents children
5.require本身是同步读取js模块文件的
6.nodejs中require的读取先后顺序
7.在模块加载机制中nodejs采用延时加载的策略，只有在用到的时候才会加载，加载完成后会放到binding_cache中，缓存的是module对象；
8.模块分为，核心模块(直接通过模块名引入) 文件模块(路径引入) 包(模块名引入)
9.文件模块分三种，默认会自动给模块添加后缀进行加载 js json node，加载过程中是以同步阻塞模式判断文件是否存在，从性能优化的角度，.json .node文件最好加上扩展名
10.require可以引入核心二进制模块，文件模块(js文件模块 json文件模块 node文件模块)
11.require加载模块的机制，首先加载核心模块，因为核心模块已经被编译成二进制加载到系统内存中了，速度快，效率高，其次按照相对路径和绝对路径查找，没有扩展名就自动按照js json node添加扩展名，最后会搜索node_modules目录，首次加载这类模块最慢，找不到会去父级node_modules目录查找，找到后会缓存起来，以后加载会很快；
12.node_modules是固定好的包管理文件夹，npm包管理器下载后的包都存在这个文件夹里面，定义一个包需要package.json和index.js入口文件，如果这个包有其他依赖就放在它的node_modules里面,另外还有libs存放其他依赖文件，bin存放二进制文件


第三节课
1.nodejs中的循环引用，是采用nodejs引擎自由的一套处理机制来处理的，以断点为出口执行其他模块，然后以断点为入口进行返回执行断点以后的代码。
2.nodejs中读取JSON文件，可以直接使用require即可，无需通过fs读取
3.var a = require('./a') var b = require('./b');这里如果a和b文件模块相互引用了，第一次引入a时，b的module就已经放到内存缓存中了，下次引用文件模块b时就直接去b的module中取方法和属性，而不会执行b里面的无关代码了
4.npm i -g 属于全局安装命令行，放在npm安装时就创建的一个全局目录里面，npm i 只是安装依赖包文件
6.Sea.js开始解决了依靠html来加载各个js文件了，JS中可以加载其他的JS了，解决了文件依赖的问题了
7.module.exports本身就是一个对象，用于打破封装性
8.require的原理，创建了script标签，引入js
9.exports是module.exports的别名
var module = {} module.exports = {} var exports = module.exports,这个时候exports=123，module.exports还是{}，所以别名只能用于添加属性；

第二节课
1.内核->js引擎(转化，移植性)，js引擎套一个壳子，写js代码传递给js引擎操作硬件就是nodejs
2.nodejs V8引擎去解析js，没有浏览器兼容性问题；
3.理解：nodejs是js的运行平台
4.事件驱动，无阻塞，看似单线程，其实是看到的是主线程一个人在忙，主线程看到异步任务会安排子线程来处理，底层还是多线程的
5.js->v8->中间层libuv(C++编写)->操作硬件就是nodejs
6.云服务器就是一台电脑，需要外网ip，我们自己只有内网ip
7.node+回车进入repl交互式运行环境，用于试验api
8.Zeal离线文档查找工具

第三节课
1.进程，线程，单线程 多线程 线程包括同步队列 异步队列（事情接收到了就分配下去，callback的时候就回调出去）
2.所有的定时器都是异步的
3.线程执行队列中的同步队列和异步队列，会先执行所有同步队列，然后再执行里面异步队列，一个同步队列卡住了，整个线程都会卡住
4.异步非io操作，setTimeOut setInterval异步最终还是在主线程执行，异步IO操作，文件操作 网络操作 fs但不会阻塞原理是node底层还是采用多线程的，看是单向线的底层的多线程的
5.callback里面的事情还是交给主线程来干，主线程绝不执行异步，只做判断交给子线程来做，最后回调都在主线来执行，把主线程想成包工头，同步的事情他来做，异步的他来安排子线程做，一直处于自由灵活的状态，所以看起来就是单线程，实际上有多线程
6.异步队列交给子线程来做了
7.有个线程池，有几个备用子线程在里面休息，我们来写异步，系统自己安排子线程，所以我们写的是异步，没写过开启子线程
8.node不擅长做大量运算的东西，比如加密解密涉及大量运算，这叫做CPU密集型操作
9.复习以下GCD对线程，对比区别
10.nvm npm nrm(改变npm的数据源)
11.nodejs里面处理回调的时候约定使用这种(err,data)=>{},if (err) {callback(err)} if (data) {callback(null,data)}，以后我也这样用
12.文件模块中使用了module.exports={},那么相当于把默认空对象指向了其他的对象并将其返回了，再用exports输出是无效的

第四节课
1.fs模块中readFile有三个参数，如果‘utf8’不传，就会返回Buffer对象，存储的是二进制01编码；
2.同步一般使用return进行返回，异步使用callback，同步中不要使用callback处理，没有意义；
3.require引入模块进来后，执行代码的时候，如果调用了require模块的代码，相当于是把module.exports的代码拿到这个文件地方执行，引用路径是相对于执行的当前文件的，如果读取路径要是当前本文件的路径，就加__dirname + ‘/config.json’;
4.__dirname会在require出去的时候已经换算出来了路径传递过去了
5.throw出去，代码就不执行了，抛出错误了
6.同步代码里面要大量使用try catch，try catch是同步代码，不能捕获异步里面的代码，如果要捕获异步里面的代码，那么需要把try catch放到回调里面进行捕获，回调里面又到了主线程；
7.异步里面的err其实和里面放trycatch捕获的异常是一样的
8.var err = new Error; err.code = 100,用于判断系统的error在返回自己的error；
9.readFile(‘./’,’utf8’,callback) writeFile(‘’,内容，‘utf8’,callback)
10.appendFile追加文件 mkdir(‘./a’,(err)=>{})创建目录 
11.fs.readdir(‘./’, (err, files是数组)=>{}) 读文件夹没有编码格式,只读当前文件夹中的内容，返回所有文件名数组，不带路径
12.fs.access(‘./a’,()=>{})判断文件夹或者文件是否存在
13.nodejs中有多个异步时，由于异步处理完成后都会回到js主线程，如果在回调中处理CPU密集型任务，如解压，压缩等，就会造成主线程阻塞，后面的异步的回调阻塞起来；
13.fs.stats(‘./a’,(err, stats)=>{})判断文件是否是文件或者目录 大小等属性
14.path模块会帮我们处理好路径，使用__dirname拼接时，处理好路径提高了代码的容错性path.join(__dirname, ‘./a’)
15.path.basename(‘./a.js’)通过路径取带后缀的文件名,同步方法
16.path.basename(‘./a.js’,’.js’)通过路径取不带后缀的文件名,同步方法
17.path.dirname(‘/foo/bar/baz/test.js’)获取所在文件夹路径
18.path.extname(‘/ac/sc/js.js’)

第五节课
1.js的调试，如果是浏览器上调试可以再资源中找到js文件加断点 debugger console.log
2.如果是nodejs的调试，可以使用node debug test.js，n跳过方法 s进入方法 o出方法 node-inspector也可以
3.也可以使用webstorm中的Run下的debug继续调试，运行debug就会停留在断点处，里面有刷新，进入下一个断点，取消全部断点的功能；VS Code IDE开发软件
4.'use strict'严格模式，防止出现怪异现象 ，严格模式a=1就报错，let作用域方括号里面，如for循环里的使用的每一个{}中的i都是唯一的,每个{}中的i是一个新的变量，作用于{}中，比较类似于闭包里面维系变量
5.以后node使用中就使用let const,引入模块使用const声明
6.如果模块中使用多个exports.进行导出，可以使用const {test} = require('/test')来导入其中模块某些属性方法
7.写css的时候，&.seleted是stylus里面的，如果是style里面的话，cls.selected是一样的，previousElementSibling获取下一个兄弟标签





