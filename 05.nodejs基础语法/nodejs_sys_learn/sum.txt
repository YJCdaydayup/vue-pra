第一节课
1.模块化，解决命名冲突和文件依赖和无法私有性，如日志模块,最早常采用命名空间法来做的，var caculator = {}, caculator.add=function() {}
2.驼峰命名法+匈牙利命名法(加上了类型)如numA，fnCaculator=function(){}
3.还可以使用(function(){})()来定义模块
4. Sea.js是CMD的规范，阿里巴巴的玉伯开发的
5.开发环境用原版的jquery.js的话，生产环境要用jquery.min.js文件，请求的文件更小
6.Sea.js开始解决了依靠html来加载各个js文件了，JS中可以加载其他的JS了

第二节课
1.nodejs中每个文件都是一个模块，通过module.exports输入，通过require打破封装性进行引入；
2.require的原理，通过module.exports输入后，require本身是一个函数，引入路径参数后，读取js模块文件内容进行拼接字符串，然后eval执行获取函数，执行和这个函数的到js模块里面exports或者module.exports输入的函数或数据；
3.module就是一个全局属性，通过require后，第一次会执行js里面所有的代码，然后将module对象缓存起来，下次require直接从缓存中module对象中取，js模块中无关代码不会再执行；
4.module对象包含id(最外层的是.)，export对象 parents children
5.require本身是同步读取js模块文件的
6.nodejs中require的读取先后顺序
7.在模块加载机制中nodejs采用延时加载的策略，只有在用到的时候才会加载，加载完成后会放到binding_cache中，缓存的是module对象；
8.模块分为，核心模块(直接通过模块名引入) 文件模块(路径引入) 包(模块名引入)
9.文件模块分三种，默认会自动给模块添加后缀进行加载 js json node，加载过程中是以同步阻塞模式判断文件是否存在，从性能优化的角度，.json .node文件最好加上扩展名
10.require可以引入核心二进制模块，文件模块(js文件模块 json文件模块 node文件模块)
11.require加载模块的机制，首先加载核心模块，因为核心模块已经被编译成二进制加载到系统内存中了，速度快，效率高，其次按照相对路径和绝对路径查找，没有扩展名就自动按照js json node添加扩展名，最后会搜索node_modules目录，首次加载这类模块最慢，找不到会去父级node_modules目录查找，找到后会缓存起来，以后加载会很快；
12.node_modules是固定好的包管理文件夹，npm包管理器下载后的包都存在这个文件夹里面，定义一个包需要package.json和index.js入口文件，如果这个包有其他依赖就放在它的node_modules里面,另外还有libs存放其他依赖文件，bin存放二进制文件


第三节课
1.nodejs中的循环引用，是采用nodejs引擎自由的一套处理机制来处理的，以断点为出口执行其他模块，然后以断点为入口进行返回执行断点以后的代码。
2.nodejs中读取JSON文件，可以直接使用require即可，无需通过fs读取
3.var a = require('./a') var b = require('./b');这里如果a和b文件模块相互引用了，第一次引入a时，b的module就已经放到内存缓存中了，下次引用文件模块b时就直接去b的module中取方法和属性，而不会执行b里面的无关代码了
4.npm i -g 属于全局安装命令行，放在npm安装时就创建的一个全局目录里面，npm i 只是安装依赖包文件

