1.前端最火的MVVM框架，数据驱动，组件化，轻量，简洁，高效 20kb左右

2.后端交互vue-resource 前端路由vue-router 第三方js库better-scroll webpack可以将源码经过编译生成浏览器可以运行的代码 Es6 + eslint检测es6代码风格

3.View 视图DOM   ViewModel 通讯观察者   Model 数据 javascript对象 

4.Angular.js 56k 难 双向数据绑定
  react.js 44k 组件化
  vue.js都是MVVM框架 gzip后20k 借鉴了angular的指令和react的组件化，自己的特性如计算属性

5.组件设计原则 页面上每个独立的可视／可交互区域都可为一个组件，每个组件对应一个工程目录，组件所需资源在这个目录下就近维护，每个页面就是一个或多个组件的容器

6.Vue.cli是Vue的脚手架工具，目录结构 本地调试 代码部署 热加载 单元测试

模版 webpack模版，模版有很多，一般选这个

7.安装vue-cli 
  $ sudo npm install -g vue-cli
  查看模版
  $ vue list
  创建一个使用webpack模版的项目名为sell
  $ vue init webpack sell
  启动项目
  $ npm run dev

8.command + option + L代码进行自动格式化
9.注释需要留空格


*********************************
第一节课
1.传统的通过js操作dom非常耗性
2.DOM Vue JS
3.Object.defineProperty()函数，在对象的set和get方法里面对DOM。进行操作属于自动的，这样就形成了初步的数据和DOM绑定，完成此案例
4.SPA单页面应用

第二节课
前端：Vue.js 包含Vue-Router Axios Vuex(自定义组件) Util 依赖
后端 Node Express（对node.js的封装，学习此框架非常重要）
数据库 MongoDB
工具支持: vue-cli生成模版 webpack进行构建
线上部署

慕课上有Vue的基础课程
ES6要学习

第三节课
cnpm是npm使用淘宝做的的镜像
npm install -g cnpm — -registry=https://registry.npm.taobao.org,cnpm和npm是一样的
升级npm： npm install -g npm

cnpm command：
cnpm i vue — -save 安装一个包

node命令
1.先进入node的环境，写函数和变量，都是js的语法
2.node node-test.js执行js文件

第四节课
1.Vue多页面应用文件引用
  直接通过script引用vue.js
  <script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"></script>
  npm安装:
  下载vue.js包
  cnpm -i vue — -save
2.vue-cli构建SPA单页面应用
  $ sudo npm install -g vue-cli
  查看模版
  $ vue list
  创建一个使用webpack模版的项目名为sell
  $ vue init webpack demo5
  $ vue init webpack-simple demo5

  index.html单页面入口
  脚本的运行必须在对应的工程目录下
  在package.json里面找到scripts查看运行起来的脚本，执行里面的命令
  如果npm run dev跑开发模式，跑不起来，先安装依赖，在README.md里面查看使用命令

第五节课
1.{{msg}}
2.html赋值 v-html=“”
3.v-bind:id=“”
4.表达式:{{ok ? : }}
5.v-text=“”
6.v-if指令
7.过滤器 {{msg|cap}}和v-bind:id=“”

class绑定
对象语法:v-bind:class=“{active:isActive,”text-danger”:hasError}”
数组语法:v-bind:class=“[class1,class2]”

style绑定
v-bind:style=“{color:activeColor变量,fontSize:fontSize+’px’}”

条件渲染
v-show 
v-if 显示／隐藏，删除DOM
v-else
v-else-if 
v-cloak 

事件处理器
v-on:click=
@click
(stop冒泡 prevent默认事件 self绑定自己，子元素无作用 once绑定一次)

v-on:keyup.enter监听enter键的事件

组件
全局组件（多页面）和局部组件(SPA)
父子组件，父—>prop—>子组件 子—>emit—>父 父子组件通信
slot插槽


第六节课
前端路由: SPA程序，只改变内容，结构不变
优点，体验好，看似10张页面，实际一张，速度快
缺点，不利于SEO，不利于百度搜到，前进后退重新发请求，无法缓存
     无法记住滚动条的位置

vue-router构建SPA关键
<router-link>标签跳转，类似a标签，this.$router.push({path:””})
<router-view>标签渲染

 	
动态路由匹配
./ 当前目录
../ 上级目录
@配置里面设置了属于src目录
{{$route.params.username}}

嵌套路由
就是一种a标签，实现页面的跳转跳转后，又是一个新的页面，这个页面会包含上一级页面的内容，以及自己页面的内容

编程式路由
通过js实现页面跳转
$router.push(“name”)
$router.push({path:”name”})
$router.push({path:”name?a=123”})或者$router.push({path:”name”})
$trouter.go(1/-1)

命名路由和命名视图


第七节课
1.通过CDN引入vue.resource.min.js
2.通过npm安装 npm install vue-resource - - save

7种api
get(URL,[])
head
Delete
Jsonp
Post
put
Patch

Url
Method
Body
Params
headers
Timeout
Before
Progress
credientials 传递凭证
emulateHTTP 在请求头里设置

全局拦截器
Interceptors,管理loading

GET,POST,JSONP,HTTP

Axios异步请求插件
CDN方式
npm install axios - -save


第八节课
ES6简介
1.函数的Rest参数和扩展
2.Promise使用
3.moudle.exports和ES6
4.import 导入
5.export 导出


第九节课
AMD,是Reuqire.js推广过程中的产出物，动态异步的加载js文件，依赖前置,require.js也完善了CMD
定义模块的时候:
define([‘package/lib’],function(lib){
   function foo(){
	lib.log(‘hello world!’);
   }

   return {
      foo: foo;
   }
})

CMD,是SeaJS在推广过程中对模块化定义的产出物，同步模块定义，淘宝团队，依赖就近，什么地方使用，就在什么地方require:
   define(function(require, exports,module){
      // 通过require引入依赖
      var $ = require(‘jquery’);
      var Spinning = require(‘./spinning’);
   });


CommonJs,module.exports node.js才使用的
export.area = function(r) {
    return Math.PI * r * r;
  }

ES6:export import
export default {
   props:[“num”],
   data() {
     return {}
   },
   methods: {
     increment() {
       this.$emit(“incre”);
       
       // 导入外部js
       import(‘./../util’);
     }
   }
}

第十节课
商品列表基础组件拆分
Header组件
Footer组件
面包屑组件

组件和页面要区分开，虽然都是.vue文件
assets 存放组件的相关资源
static 存放页面相关的资源

第十一节课
1.mock数据，渲染列表信息
2.最新版的vue-cli的配置中浏览器服务都在webpack.dev.server这个插件中，所以本地服务器的处理在webpack.dev.conf.js中修改，安装express cnpm install express — —save-dev

3.图片懒加载插件 在npm里面搜索vue-lazyload 安装cnpm i vue-lazyload — —save

4.created:在组件渲染成html前调用 mounted:组件渲染成html后调用，这个时候各个标签已经渲染出来了，相当于window.onload方法

5.服务网络请求时，网络配置修改以及请求的文件修改后，必须重新启动项目

6.不支持ifelse语句，使用三元运算，里面的用法和js一样的 {{index == 0 ? 'All': price.minPrice + ' - ' + price.maxPrice}}

7.{{}}里面支持js语法，字符串用'', 不支持js自定义的变量 不能有var ，可以访问白名单里面的Math和Date




   








