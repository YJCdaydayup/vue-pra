x一.箭头函数和普通函数的区别
1）箭头函数是匿名函数，不能作为构造函数，不能使用new，没有原型属性prototype
2）箭头函数不绑定arguments，使用rest参数...解决； const fn = (...x) => {console.log(x)},这里的x是数组
3）箭头函数不绑定this，会与父作用域共享上下文this
4）箭头函数不能作为generator生成器函数，不能使用yield关键字

二.宏任务和微任务有哪些
1）宏任务：主代码块 settimeout setinterval setImediate requestAnimationFrame
2）微任务：process.nextTick Promise.then() MutationObserver

三.peerDependencies作用
1）在npm2中，如果A模块依赖了B模块，在安装A模块后，如果需要直接使用B模块，可以再次安装B模块，但是也可以不在当前项目中的package.json中声明B的依赖，而是在A的package.json里面加上peerDependencies,就会安装A模块的时候自动安装B模块
2）npm3中不会强制安装peerDependencies中的依赖包，而是会打印警告让用户安装

四.requestAnimationFrame
1）实现动画的方式有animation transition setInterval，还可以通过requstAnimationFrame
2）屏幕刷新率一般为每秒60HZ，每16.7ms会刷新一次，由于人的视觉暂留会看起来是流畅的
3）setTimeout来设定间隔改变位置，容易出现卡顿，抖动现象，由于settimeout属于宏任务，会等到主线程执行完毕后再执行，实际执行时间会比设定的晚，而且容易丢帧
4）requestAnimationFrame会在屏幕每次刷新间隔执行一次不会卡顿，当屏幕最新化或者隐藏时刷新任务会被系统暂停，requestAnimationFrame也会停止渲染，节省CPU开销
5）为了解决兼容性问题，优雅降级，优先使用高级特性，再根据不同情况回退，直到使用settimeout
代码：
    var progress = 0;
    //回调函数
    function render() {
     progress += 1; //修改图像的位置
     if (progress < 100) {
     //在动画没有结束前，递归渲染
     window.requestAnimationFrame(render);
     }
    }
    //第一帧渲染
    window.requestAnimationFrame(render);</pre>

五.虚拟DOM理解
1）是跟随React框架产生的，Facebook提出来，为了兼顾效率和性能；
2）一般操作DOM结构是非常昂贵的，DOM改动后，整个容器中的内容都要重新渲染一遍，项目比较复杂的话是非常影响性能的，虚拟DOM看作使用JS模拟DOM树形结构，很好的解决这个问题；
3）原生DOM： 创建DOM渲染显示，虚拟DOM，创建虚拟DOM转换成实际的DOM树渲染显示，所以首次加载会慢些；
4）虚拟DOM：当DOM发生变化时，会产生一份虚拟DOM的副本，其中包含想要进行的更改，通过diff算法对比出一个差异，一旦确定了所有差异，就可以更新DOM

六.HTTPS用的是对成加密还是非对称加密
1）证书的验证是浏览器完成的，在iOS中使用https时，如果ssl证书不是正规的证书，需要在代理方法里面设置信任此证书，正规的证书不需要设置，浏览器一样，会提示安全风险，需要点击信任才可以访问；
2）证书包含公钥，颁发机构信息，域名，有效期等
3）包含：证书验证属于非对称加密，数据传输属于对称加密
   里面的验证和数据传输时浏览器帮忙发器请求时处理了，有的需要手动安装证书来进行授信：
   证书验证阶段：发起https请求，服务器返回https证书，客户端娇艳证书，不合法提示警告
   数据传输：证书合法后，客户端生产随机数，公钥加密随机数给到服务器，服务器解密得到随机随，开始数据对称加密传输

七.loader和plugin的区别
1）webpack只能理解js和JSON文件，对于其他资源，如css，less，sass，图片等，需要不同的loader来进行解析
2）plugin属于webpack功能的扩展，解决loader无法实现的事情，比如打包优化，压缩，提供公共模块
3）webpack4提供了mode选项，可以不需要配置文件，使用一些默认的配置进行打包
4）预设presets，预设是结合babel-preset-env来使用，还有stage-2配置都是转义器，主要对最新的语法糖进行编译，比如let，const，promise
5）babelrc里面的plugin插件，来处理一些需求，像transform-runtime，会对es6的语法进行转换，而不会对新的api进行转换，比如Promise，这时候可以考虑babel-polyfill来适配低版本的浏览器
6)自己开发loader时，loader是一个函数，plugin是一个类,需要实现apply传入compiler对象，这个complier对象就是webpack实例，通过hooks来确定打包生命周期函数如hook.emit输出包的时刻里面callback一定要调用，hook.complie


八.Vue中Key的作用
1）如果不加key，Vue默认会主意对比前后生成的虚拟DOM节点，发现某个节点变化了就用这个节点替换当前的节点，而旧的节点里面的元素会就地复用；
2）为了解决删除节点就是将这个节点完全删除，引入key作为id，如{id: 1, value: 1},{id: 2,value:2},{id: 3, value: 3},变成{id: 1, value: 1},{id: 3, value: 3}，会先对比id，变成了1，3，所有代表2被删除了，然后再对比1和3里面的元素，没有发生变化

